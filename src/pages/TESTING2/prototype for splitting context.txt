
write a wrapper that returns the view frtom the context
  add the correct state into the view as a prop

  usserpagewrapper:
    userpage statae (data/loading/callout)
    {c1, c2, c3, c4} = guestpage context
    render <map props=(c1, c3.. dependenciy contextes (for handlers/data) )>
    render <list props=(c1, c3.. dependenciy contextes)>
    render <filter props=(c1, c3.. dependenciy contextes)>



  const { onFetch } = useAPI()

    /* primarly JSON returned from callout */
    const [data, setData] = useState();

     /* callout status, t for success, f for failure */
    const [status, setStatus] = useState(undefined)

    /* copy of data from callout */
    const [posts, setPosts] = useState(undefined);
    
    /* UI state */
    const [loading, setLoading] = useState(true);

    /* arr of filtered posts to be displayed in list */
    /* prevent the double useEffect call/double fetch() on first render */
    const dataFetchedRef = useRef(false);

   
    const success = (r) => {
      console.log("setposts UP: ", r)
      setData(r); 
      /** */
      setFilteredPosts(r.posts)
      /******************************************** */
      //here i could do another callout to fetch appointments for a  location    
    }

    const failure = (r) => {
      console.log("error UP", r.reason) 
      setData(r);  
    }

    const finish = (r) => {
      console.log("setloading UP")
      setLoading(false)
    }


    useEffect( () => {
        
      /* this is the pattern utilized for all async calls in functional components 
      prevents useEffect() from firing twice on init */
        if(dataFetchedRef.current) return

        const dataFetch = async () => {     
          onFetch(success, failure, finish)
        };

        dataFetchedRef.current = true;
        dataFetch();
        //onFetch();

        //add cleanup code for the handler? (like gmaps does)
    }, );

    
    const value = {
        // GUEST AND USER CONTEXT
        data, loading, selected, filteredPosts, filters ,
        handleSelectedLocation: selectLocation,
        handleSelectFilter : selectFilter ,
        handleDeselectFilter : deSelectFilter,
        // USER CONTEXT ONLY
        appointments, selectedAppointment,
        handleSelectAppointment: selectAppointment,
    };
    

    /*
    const contextData = { this context produces data
      data,
      loading,
      //status,
     // posts,
    }

    const contextAppointment = {
      appointments, selectedAppointment,
      handleSelectAppointment: selectAppointment,
      dependencies:{ 
        data: data 
        }
      API: {
        selectLocationAppointments: selectLocationAppointments,
        setSelectedAppointment: setSelectedAppointment:,
        }

      }
    }

    const contextSelectedLocation = {
      selected,  
      handleSelectedLocation: selectLocation, // this handler gets consumed on 2 views 
      setSelected, // these setters should have wrappers to prevent bad inputs from producers
      // dependencies/ updating state of other components
      selectLocationAppointments,
      setSelectedAppointment,
    }

    

    const contextFilters = {
      filters, filteredPosts,
      handleSelectFilter : selectFilter ,
      handleDeselectFilter : deSelectFilter,
    }

    const value = {
      contextData( dependencies ), //// pass this to the map/location list
      contextShared, //  pass this to map/location list
      contextAppointment, //pass this to the appt list
      contextFilters //pass this to the filters list
  };
*/
    return (
        <UserContext.Provider value={value}>
          {children}
        </UserContext.Provider>
      );
}

const AppointmentContext = ( { props } ) =>{

    const {data} = props.context.dependencies

    const [appointments, setAppointments] = useState([]);

    /* id of a selected (highlighted) appointment */
    const [selectedAppointment, setSelectedAppointment] = useState();

    const selectLocationAppointments = (id) => {

        //this line is using array.find() to return the post object with id equal to passed in id, then reading the appointments array
        const appts = data.posts.find( (post) => {return post.id === id} ).appointments
        setAppointments(appts)
      }

      const selectAppointment = (id) => {
        return (e) => {
          e.preventDefault();
          console.log("select APPOINTMENT: ", id)
          setSelectedAppointment(id)
      }}

      const getHooks = () =>{
        return [ appointments, 
                setAppointments, 
                selectedAppointment, 
                setSelectedAppointment ] = [ appointments, setAppointments, selectedAppointment, setSelectedAppointment ] 
      }
}

const selectLocationContext  = ( { props } ) =>{

    const { selectLocationAppointments, setSelectedAppointment } = props.context.dependencies
      /* track the id of the selected entity to update map/list*/
    const [selected, setSelected] = useState();

    //selectLocationAppointments(id)

    const selectLocation = (e, id) => {
        //e.preventDefault();
        console.log("select location GP: ", id)
        setSelected(id)
        // when user clicks on a location, set the appointments array
        selectLocationAppointments(id)
        //.. and erase the current selected appointment
        setSelectedAppointment()
      }

}

export const filterContext = ( { props } ) =>{

    const { data } = props.context.dependencies

    const [filteredPosts, setFilteredPosts] = useState([])

    //console.log("filteredPosts: ", filteredPosts)

    /* arr of selected filters */
    const [filters, setFilters] = useState([]);
   
const selectFilter = (iconName) => {
    return (e) => {
      e.preventDefault();
      console.log("select FILTER GP: ", iconName, filters)
      const copyFilters = [...filters].concat( [iconName] )
     updateFilters (copyFilters)
  }}

  const deSelectFilter = (iconName) => {
    return (e) => {
      e.preventDefault();
      console.log("deselect FILTER GP: ", iconName, filters)
      const copyFilters = [...filters.filter( (element) => {return element !== iconName} )]
      updateFilters (copyFilters)
  }}

  const updateFilters = (updatedFilters) => {

    // A AND B AND C.. filter for tags/icons
    /* this peice of code sais:
        for EACH post p:
          is every string within updatedFilters included in p.icons string array ? (thats what arr.every(..) does)
    */
   //the output is a list of posts with icons that contains all the entries in filters
    setFilteredPosts(data.posts.filter( (post) => updatedFilters.every( (filterName) => post.icons.includes(filterName) ) ))
    //batch update both the new filters and the filtered list
    setFilters(updatedFilters)
  }

}